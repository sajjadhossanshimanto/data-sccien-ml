ðŸŽ¯ ð—§ð—¼ð—±ð—®ð˜†'ð˜€ ð—Ÿð—²ð˜€ð˜€ð—¼ð—» : ð—¢ð˜ƒð—²ð—¿ð˜ƒð—¶ð—²ð˜„ ð—¼ð—³ ð—£ð—®ð—»ð—±ð—®ð˜€ ð—œð—»ð—±ð—²ð˜…ð—¶ð—»ð—´ ð—®ð—»ð—± ð—¦ð—²ð—¹ð—²ð—°ð˜ð—¶ð—¼ð—»

Todays lecssion wat a bit insence competing to other days, although everything is at basic level. For practising today's lecssion we start by creating a datagram with random data of (5x5) and assigned alphabetical row and column label.

ðŸ”¹ð—–ð—¼ð—¹ð˜‚ð—ºð—» ð—¦ð—²ð—¹ð—²ð—°ð˜ð—¶ð—¼ð—»:
â— By use ð˜€ð—¾ð˜‚ð—®ð—¿ð—² ð—¯ð—¿ð—®ð—°ð—¸ð—²ð˜ð˜€ [] we are allowed to access columns by name.
â— ð—±ð—³[['ð—ª','ð—­']] -> we can also pass multiple columns.

ðŸ”¹ð—¥ð—¼ð˜„ ð—¦ð—²ð—¹ð—²ð—°ð˜ð—¶ð—¼ð—»:
 [] can't be used to access data on rows directly. Rather pandas provides us with .loc and .iloc attribute:
â— .ð—¹ð—¼ð—°['A'] -> for label-based indexing.
â— .ð—¶ð—¹ð—¼ð—°[2] -> for integer-based indexing.
â—Œ Both can also take column names as the second argument, giving powerful selection capabilities.

ðŸ”¹ð—–ð—¼ð—»ð—±ð—¶ð˜ð—¶ð—¼ð—»ð—®ð—¹ ð—¦ð—²ð—¹ð—²ð—°ð˜ð—¶ð—¼ð—»:
â— We can use the same ð˜€ð—¾ð˜‚ð—®ð—¿ð—² ð—¯ð—¿ð—®ð—°ð—¸ð—²ð˜ð˜€ [] to filter rows based on conditions. df[df['A'] > 0] 
â—Œ ð—±ð—³['ð—”'] > ðŸ¬ -> comparing a datafram with any condition returns a true false
â—Œ ð—±ð—³[ð—±ð—³['ð—”'] > ðŸ¬] -> which can be used for bit masking.

ðŸ”¹ð— ð˜‚ð—¹ð˜ð—¶ð—½ð—¹ð—² ð—–ð—¼ð—»ð—±ð—¶ð˜ð—¶ð—¼ð—»ð˜€:
â— Combine conditions using logical operators (&, |, ~).
â—Œ df[(df['A'] > 0) & (df['B'] < 1)] selects rows where A is greater than 0 and B is less than 1.

ðŸ”¹ð—¥ð—¼ð˜„ ð—®ð—»ð—± ð—–ð—¼ð—¹ð˜‚ð—ºð—» ð——ð—²ð—¹ð—²ð˜ð—¶ð—¼ð—»:
â— Use .drop() to remove rows or columns.
â—Œ  df.drop("W") -> removes columns.
â—Œ  df.drop("A", axis=1) -> removes rows.